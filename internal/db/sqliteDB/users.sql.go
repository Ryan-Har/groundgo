// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: users.sql

package sqliteDB

import (
	"context"
)

const checkEmailExists = `-- name: CheckEmailExists :one
SELECT
    COUNT(id)
FROM
    users
WHERE
    email = ?
`

// Checks if an email address already exists in the database.
// Returns a count (0 or 1).
func (q *Queries) CheckEmailExists(ctx context.Context, email string) (int64, error) {
	row := q.db.QueryRowContext(ctx, checkEmailExists, email)
	var count int64
	err := row.Scan(&count)
	return count, err
}

const createUser = `-- name: CreateUser :one
INSERT INTO users (
    id,
    email,
    password_hash,
    role,
    claims,
    oauth_provider,
    oauth_id
) VALUES (
    ?,?, ?, ?, ?, ?, ?
)
RETURNING
    id,
    email,
    password_hash,
    role,
    claims,
    oauth_provider,
    oauth_id,
    created_at,
    updated_at,
    is_active
`

type CreateUserParams struct {
	ID            string  `json:"id"`
	Email         string  `json:"email"`
	PasswordHash  *string `json:"passwordHash"`
	Role          string  `json:"role"`
	Claims        *string `json:"claims"`
	OauthProvider *string `json:"oauthProvider"`
	OauthID       *string `json:"oauthId"`
}

// Inserts a new user into the database.
// Returns the newly created user's ID.
func (q *Queries) CreateUser(ctx context.Context, arg CreateUserParams) (User, error) {
	row := q.db.QueryRowContext(ctx, createUser,
		arg.ID,
		arg.Email,
		arg.PasswordHash,
		arg.Role,
		arg.Claims,
		arg.OauthProvider,
		arg.OauthID,
	)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Role,
		&i.Claims,
		&i.OauthProvider,
		&i.OauthID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
	)
	return i, err
}

const deleteUser = `-- name: DeleteUser :exec
DELETE FROM
    users
WHERE
    id = ?
`

// Deletes a user from the database by their ID.
func (q *Queries) DeleteUser(ctx context.Context, id string) error {
	_, err := q.db.ExecContext(ctx, deleteUser, id)
	return err
}

const getUserByEmail = `-- name: GetUserByEmail :one
SELECT
    id,
    email,
    password_hash,
    role,
    claims,
    oauth_provider,
    oauth_id,
    created_at,
    updated_at,
    is_active
FROM
    users
WHERE
    email = ?
`

// Retrieves a user by their email address.
// Used for login and checking existing registrations.
func (q *Queries) GetUserByEmail(ctx context.Context, email string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByEmail, email)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Role,
		&i.Claims,
		&i.OauthProvider,
		&i.OauthID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
	)
	return i, err
}

const getUserByID = `-- name: GetUserByID :one
SELECT
    id,
    email,
    password_hash,
    role,
    claims,
    oauth_provider,
    oauth_id,
    created_at,
    updated_at,
    is_active
FROM
    users
WHERE
    id = ?
`

// Retrieves a user by their unique ID.
// Used for session validation and fetching user details.
func (q *Queries) GetUserByID(ctx context.Context, id string) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByID, id)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Role,
		&i.Claims,
		&i.OauthProvider,
		&i.OauthID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
	)
	return i, err
}

const getUserByOAuth = `-- name: GetUserByOAuth :one
SELECT
    id,
    email,
    password_hash,
    role,
    claims,
    oauth_provider,
    oauth_id,
    created_at,
    updated_at,
    is_active
FROM
    users
WHERE
    oauth_provider = ? AND oauth_id = ?
`

type GetUserByOAuthParams struct {
	OauthProvider *string `json:"oauthProvider"`
	OauthID       *string `json:"oauthId"`
}

// Retrieves a user by their OAuth provider and OAuth ID.
// Used for logging in users who registered via an OAuth provider.
func (q *Queries) GetUserByOAuth(ctx context.Context, arg GetUserByOAuthParams) (User, error) {
	row := q.db.QueryRowContext(ctx, getUserByOAuth, arg.OauthProvider, arg.OauthID)
	var i User
	err := row.Scan(
		&i.ID,
		&i.Email,
		&i.PasswordHash,
		&i.Role,
		&i.Claims,
		&i.OauthProvider,
		&i.OauthID,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.IsActive,
	)
	return i, err
}

const listAllUsers = `-- name: ListAllUsers :many
SELECT
    id,
    email,
    password_hash,
    role,
    claims,
    oauth_provider,
    oauth_id,
    created_at,
    updated_at,
    is_active
FROM
    users
ORDER BY
    created_at DESC
`

// Retrieves all users from the database.
// Useful for administrative purposes (e.g., user management panel).
func (q *Queries) ListAllUsers(ctx context.Context) ([]User, error) {
	rows, err := q.db.QueryContext(ctx, listAllUsers)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	items := []User{}
	for rows.Next() {
		var i User
		if err := rows.Scan(
			&i.ID,
			&i.Email,
			&i.PasswordHash,
			&i.Role,
			&i.Claims,
			&i.OauthProvider,
			&i.OauthID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.IsActive,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const updateUserClaims = `-- name: UpdateUserClaims :exec
UPDATE
    users
SET
    claims = ?,
    updated_at = STRFTIME('%s', 'NOW')
WHERE
    id = ?
`

type UpdateUserClaimsParams struct {
	Claims *string `json:"claims"`
	ID     string  `json:"id"`
}

// Updates a user's JSON claims data and updates the 'updated_at' timestamp.
func (q *Queries) UpdateUserClaims(ctx context.Context, arg UpdateUserClaimsParams) error {
	_, err := q.db.ExecContext(ctx, updateUserClaims, arg.Claims, arg.ID)
	return err
}

const updateUserIsActive = `-- name: UpdateUserIsActive :exec
UPDATE
    users
SET
    is_active = ?,
    updated_at = STRFTIME('%s', 'NOW')
WHERE
    id = ?
`

type UpdateUserIsActiveParams struct {
	IsActive bool   `json:"isActive"`
	ID       string `json:"id"`
}

// Updates a user's active status (e.g., for deactivation) and updates the 'updated_at' timestamp.
func (q *Queries) UpdateUserIsActive(ctx context.Context, arg UpdateUserIsActiveParams) error {
	_, err := q.db.ExecContext(ctx, updateUserIsActive, arg.IsActive, arg.ID)
	return err
}

const updateUserPassword = `-- name: UpdateUserPassword :exec
UPDATE
    users
SET
    password_hash = ?,
    updated_at = STRFTIME('%s', 'NOW')
WHERE
    id = ?
`

type UpdateUserPasswordParams struct {
	PasswordHash *string `json:"passwordHash"`
	ID           string  `json:"id"`
}

// Updates a user's password hash and updates the 'updated_at' timestamp.
func (q *Queries) UpdateUserPassword(ctx context.Context, arg UpdateUserPasswordParams) error {
	_, err := q.db.ExecContext(ctx, updateUserPassword, arg.PasswordHash, arg.ID)
	return err
}

const updateUserRole = `-- name: UpdateUserRole :exec
UPDATE
    users
SET
    role = ?,
    updated_at = STRFTIME('%s', 'NOW')
WHERE
    id = ?
`

type UpdateUserRoleParams struct {
	Role string `json:"role"`
	ID   string `json:"id"`
}

// Updates a user's role and updates the 'updated_at' timestamp.
func (q *Queries) UpdateUserRole(ctx context.Context, arg UpdateUserRoleParams) error {
	_, err := q.db.ExecContext(ctx, updateUserRole, arg.Role, arg.ID)
	return err
}
