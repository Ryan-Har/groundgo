// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.29.0
// source: revoked_tokens.sql

package sqliteDB

import (
	"context"
)

const deleteExpiredRevokedTokens = `-- name: DeleteExpiredRevokedTokens :exec
DELETE FROM revoked_tokens
WHERE original_expires_at <= strftime('%s', 'now')
`

// DeleteExpiredRevokedTokens purges tokens from the revocation list
// after they would have naturally expired. This keeps the table clean.
func (q *Queries) DeleteExpiredRevokedTokens(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteExpiredRevokedTokens)
	return err
}

const isTokenRevoked = `-- name: IsTokenRevoked :one
SELECT EXISTS(
  SELECT 1 FROM revoked_tokens WHERE id = ?
)
`

// IsTokenRevoked checks if a token's JTI exists in the revocation list.
// sqlc will generate a method that returns a boolean.
func (q *Queries) IsTokenRevoked(ctx context.Context, id string) (int64, error) {
	row := q.db.QueryRowContext(ctx, isTokenRevoked, id)
	var column_1 int64
	err := row.Scan(&column_1)
	return column_1, err
}

const revokeToken = `-- name: RevokeToken :one
INSERT INTO revoked_tokens (
  id,
  user_id,
  original_expires_at
) VALUES (
  ?, ?, ?
)
RETURNING id, user_id, revoked_at, original_expires_at
`

type RevokeTokenParams struct {
	ID                string `json:"id"`
	UserID            string `json:"userId"`
	OriginalExpiresAt int64  `json:"originalExpiresAt"`
}

// RevokeToken adds a token's JTI (JWT ID) to the revocation list.
func (q *Queries) RevokeToken(ctx context.Context, arg RevokeTokenParams) (RevokedToken, error) {
	row := q.db.QueryRowContext(ctx, revokeToken, arg.ID, arg.UserID, arg.OriginalExpiresAt)
	var i RevokedToken
	err := row.Scan(
		&i.ID,
		&i.UserID,
		&i.RevokedAt,
		&i.OriginalExpiresAt,
	)
	return i, err
}
